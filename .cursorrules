# Kenya Track and Trace System - Cursor AI Rules

## üö® CRITICAL: Database Naming Convention

### PostgreSQL Schema Standard: snake_case ONLY
- ALL database columns MUST use snake_case (e.g., user_id, created_at, event_type)
- ALL table names MUST be plural snake_case (e.g., epcis_events, facility_inventory)
- NEVER use camelCase for database columns (e.g., userId, createdAt are FORBIDDEN)
- See DATABASE_NAMING_AUDIT.md for complete audit and rationale

### Foreign Key Naming
- Format: {table_singular}_id (e.g., user_id, batch_id, product_id, facility_user_id)
- ALWAYS snake_case
- Reference users.id as user_id (not userId)
- Reference batches.id as batch_id (not batchId)

### Timestamp Columns
- ALWAYS use: created_at, updated_at (NEVER createdAt, updatedAt)
- Use PostgreSQL type: timestamp without time zone
- Default: now() or CURRENT_TIMESTAMP

### Before Creating ANY New Table or Column
1. Check existing database schema first:
   ```bash
   cd kenya-tnt-system
   docker-compose exec postgres psql -U tnt_user -d kenya_tnt_db -c "\d tablename"
   docker-compose exec postgres psql -U tnt_user -d kenya_tnt_db -c "\dt"
   ```
2. Follow snake_case pattern from epcis_events and facility_* tables
3. Reference DATABASE_NAMING_AUDIT.md for examples

---

## üéØ TypeORM Entity Rules

### Entity Property Naming
- Entity properties MUST match database column names EXACTLY
- Use snake_case for all properties (matches PostgreSQL schema)
- Example: `user_id: string` not `userId: string`

### Column Decorators
- ‚ùå AVOID: @Column({ name: 'column_name' }) unless bridging legacy camelCase tables
- ‚úÖ PREFER: @Column() with property name matching database column
- If you see @Column({ name: '...' }), question whether it's needed

### TypeORM Configuration
- NO naming strategy (synchronize: false in database.module.ts)
- Comment on line 84 explains: "database uses camelCase columns" (this is WRONG - will be migrated to snake_case)
- Current reality: Mixed naming (being standardized to snake_case)

### Entity Examples (Follow These Patterns)

‚úÖ CORRECT - snake_case matching database:
```typescript
@Entity('epcis_events')
export class EPCISEvent {
  @Column({ unique: true })
  event_id: string;  // Matches database column event_id
  
  @Column()
  event_type: string;  // Matches database column event_type
  
  @Column({ type: 'uuid', nullable: true })
  actor_user_id: string;  // Matches database column actor_user_id
  
  @Column({ type: 'timestamp', default: () => 'CURRENT_TIMESTAMP' })
  created_at: Date;  // Matches database column created_at
}
```

‚ùå WRONG - camelCase properties (legacy only):
```typescript
@Column()
userId: string;  // Only acceptable in legacy tables (users, batches, consignments)
```

### Reference Entities
- Gold standard: src/shared/domain/entities/epcis-event.entity.ts
- Facility examples: facility-inventory.entity.ts, facility-receiving.entity.ts
- Legacy examples (being migrated): user.entity.ts, batch.entity.ts

---

## üìÇ Project Structure

### Backend (NestJS + TypeORM)
- **Core monolith**: kenya-tnt-system/core-monolith/
- **Entities**: src/shared/domain/entities/
- **Services**: src/modules/{auth,analytics,ppb,manufacturer}/
- **Database**: PostgreSQL via docker-compose

### Frontend (React + TypeScript)
- **Webapp**: epcis_track_and_trace_webapp/
- **Mobile**: medic-scan-fetch/

### Microservices (Legacy - being consolidated)
- epcis-auth-service/
- epcis-manufacturer-service/
- epcis-ppb-service/
- Note: Favor monolith over microservices for new features

---

## üîê NestJS Best Practices

### Module Organization
- Follow DDD structure: domain/ entities, services/ application logic
- Use @Injectable() for services
- Use @Controller() for REST endpoints
- Register entities in DatabaseModule (database.module.ts)

### Authentication
- JWT-based auth in src/modules/auth/
- User roles: 'dha', 'manufacturer', 'user_facility', 'cpa'
- Always validate user context in services

### Error Handling
- Use NestJS exceptions: BadRequestException, NotFoundException, UnauthorizedException
- Log errors appropriately
- Return meaningful error messages

---

## üìä EPCIS Standard Compliance

### Event Types
- ObjectEvent, AggregationEvent, TransactionEvent, TransformationEvent
- Follow GS1 EPCIS 1.2 and 2.0 standards
- See epcis-event.entity.ts for schema

### Business Steps (bizStep)
- receiving, shipping, packing, unpacking, dispensing, destroying
- Use GS1 vocabulary URIs when applicable

### Dispositions
- in_transit, in_progress, active, inactive, recalled
- Follow GS1 standard dispositions

### EPCs and Identifiers
- SGTIN: Serialized Global Trade Item Number
- SSCC: Serial Shipping Container Code (18 digits for packages)
- GLN: Global Location Number (13 digits for organizations)
- Format validation required

---

## üß™ Testing Requirements

### When Creating New Features
- Write unit tests for services
- Write integration tests for endpoints
- Test database migrations in development first
- Verify entity queries work with actual database

### Critical Test Scenarios
- Authentication flows (login, token refresh)
- PPB consignment import
- EPCIS event creation and journey tracking
- Facility inventory operations
- Serial number lookups

---

## üóÑÔ∏è Database Migrations

### Migration Files
- Location: kenya-tnt-system/database/migrations/
- Use sequential versioning: V11__Description.sql, V12__Description.sql
- ALWAYS use snake_case in SQL

### Migration Template
```sql
-- V{N}__{Description}.sql
-- Description: Brief explanation of changes
-- Date: YYYY-MM-DD
-- Author: Name

BEGIN;

-- Create table with snake_case columns
CREATE TABLE IF NOT EXISTS new_table (
  id SERIAL PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES users(id),
  product_id INTEGER NOT NULL REFERENCES ppb_products(id),
  quantity NUMERIC(15,2) NOT NULL,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- Create indexes
CREATE INDEX idx_new_table_user_id ON new_table(user_id);
CREATE INDEX idx_new_table_product_id ON new_table(product_id);

COMMIT;
```

### Before Running Migrations
- Backup database: `pg_dump -U tnt_user -d kenya_tnt_db > backup_$(date +%Y%m%d).sql`
- Test in development environment first
- Verify corresponding entity is updated

---

## ‚ö° TypeScript Conventions

### Naming
- Interfaces: PascalCase (e.g., CreateUserDto, JourneyResponse)
- Classes: PascalCase (e.g., AuthService, EPCISEvent)
- Functions/methods: camelCase (e.g., getUserById, createConsignment)
- Constants: UPPER_SNAKE_CASE (e.g., MAX_RETRY_ATTEMPTS)
- Database properties: snake_case (e.g., user_id, created_at)

### Imports
- Use absolute imports via tsconfig paths
- Group imports: stdlib, third-party, local
- Sort alphabetically within groups

---

## üé® Frontend (React) Guidelines

### Component Naming
- PascalCase for components (e.g., ConsignmentList, EventTimeline)
- camelCase for utilities (e.g., formatDate, parseEPC)

### API Integration
- Use environment variables for API URLs
- Handle loading/error states
- Show user-friendly error messages

### State Management
- Use React hooks (useState, useEffect, useContext)
- Consider Zustand or Redux for complex state
- Avoid prop drilling

---

## üìù Documentation Requirements

### When Adding New Features
- Update README.md if user-facing
- Document API endpoints with examples
- Add JSDoc comments for complex functions
- Update architecture diagrams if structure changes

### Code Comments
- Explain WHY, not WHAT
- Document business logic and EPCIS compliance
- Note any workarounds or temporary solutions
- Reference related entities/services

---

## üîç Code Review Checklist

Before committing, verify:
- [ ] Database columns use snake_case
- [ ] Entity properties match database exactly
- [ ] No unnecessary @Column({ name: ... }) overrides
- [ ] TypeScript compiles without errors
- [ ] Imports are organized
- [ ] No hardcoded secrets or credentials
- [ ] Error handling is comprehensive
- [ ] Tests cover new functionality

---

## üö´ Common Mistakes to AVOID

### Database Schema
- ‚ùå Creating camelCase columns (userId, createdAt)
- ‚ùå Inconsistent foreign key naming (user vs userId vs user_id)
- ‚ùå Missing indexes on frequently queried columns
- ‚ùå Using VARCHAR without length limits

### TypeORM Entities
- ‚ùå Using camelCase properties for new entities
- ‚ùå Adding @Column({ name: ... }) when not needed
- ‚ùå Forgetting to register entity in DatabaseModule
- ‚ùå Missing relationships (OneToMany, ManyToOne)

### NestJS
- ‚ùå Circular dependencies between modules
- ‚ùå Not using dependency injection
- ‚ùå Synchronous operations blocking event loop
- ‚ùå Not validating DTOs

---

## üìö Key Reference Files

When working on specific areas, reference these files:

### Database & Entities
- DATABASE_NAMING_AUDIT.md - Complete naming convention audit
- kenya-tnt-system/SNAKE_NAMING_STRATEGY_REMOVAL_SUMMARY.md
- kenya-tnt-system/MIGRATION_STRATEGY.md
- src/shared/domain/entities/epcis-event.entity.ts (gold standard)

### Architecture
- ARCHITECTURE.md
- kenya-tnt-system/core-monolith/JOURNEY_TRACKING_IMPLEMENTATION.md

### EPCIS
- epcis-hardening-plan.md
- FLMIS_EVENT_VERIFICATION_REPORT.md

### Business Logic
- src/modules/ppb/ppb.service.ts - PPB consignment imports
- src/shared/analytics/journey/journey.service.ts - Journey tracking

---

## üéØ When Creating New Features

1. **Check existing patterns first**
   - Review similar existing features
   - Check database schema: `\d tablename`
   - Follow established conventions

2. **Database changes**
   - Create migration file (snake_case SQL)
   - Update/create entity (snake_case properties)
   - Register entity in DatabaseModule
   - Test in development

3. **Service layer**
   - Create/update service with business logic
   - Use TypeORM repositories
   - Handle errors gracefully
   - Add logging

4. **Controller/API**
   - Create/update controller
   - Validate DTOs
   - Document endpoints
   - Test with actual requests

5. **Frontend (if needed)**
   - Create/update React components
   - Integrate with API
   - Handle loading/error states
   - Test user flows

---

## üîÑ Current Migration Status

‚ö†Ô∏è **Active Migration**: Standardizing database to snake_case
- Old tables (users, batches, consignments): Currently camelCase ‚Üí Will migrate to snake_case
- New tables (epcis_*, facility_*, product_*): Already snake_case ‚úÖ
- See DATABASE_NAMING_AUDIT.md for complete plan
- Until migration complete: Legacy tables may have camelCase columns

**When in doubt**: Follow the snake_case convention (PostgreSQL standard)

---

## üí° Pro Tips

1. **Always check the database before coding**
   - Don't assume column names
   - Verify with `\d tablename`

2. **Reference existing code**
   - EPCIS events = gold standard for new features
   - User/Batch entities = legacy (being updated)

3. **Test database changes locally first**
   - Never test migrations in production
   - Use docker-compose for local DB

4. **Ask for clarification**
   - If unsure about naming, ask!
   - Better to clarify than create inconsistency

---

**Last Updated**: December 9, 2025
**Maintained By**: Development Team
**Questions?**: Reference DATABASE_NAMING_AUDIT.md or ask the team

